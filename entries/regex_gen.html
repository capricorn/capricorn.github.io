<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>regex_gen</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="minimum-hamming-distance-convolution-traversal-part-i">Minimum
Hamming Distance Convolution Traversal, Part I</h1>
<p>Say that you want to generate a regex of the form</p>
<pre><code>a*b*</code></pre>
<p>The following describes valid strings of this type: <span
class="math display"><em>i</em>, <em>j</em> ≥ 0, <em>a</em><sup><em>i</em></sup><em>b</em><sup><em>j</em></sup></span></p>
<p>e.g. <span
class="math inline"><em>a</em><sup>3</sup><em>b</em><sup>0</sup> = <code>aaa</code></span></p>
<p>Next, another constraint: only generate strings of length <span
class="math inline"><em>l</em></span>. That is, <span
class="math display"><em>i</em> + <em>j</em> = <em>l</em></span></p>
<p>which is a convolution. I will write a convolution of <span
class="math inline"><em>k</em></span> integers that sum to <span
class="math inline"><em>l</em></span> as <span
class="math inline">Conv<sub><em>l</em>, <em>k</em></sub></span>. This
represents the set of all solutions as k tuples.</p>
<p>For now I’ll just consider 2-convolutions, i.e. <span
class="math inline">Conv<sub><em>l</em>, 2</sub></span>. It’s definition
is: <span
class="math display">Conv<sub><em>l</em>, 2</sub> = {(<em>a</em>,<em>b</em>)|<em>a</em>, <em>b</em> ≥ 0, <em>a</em> + <em>b</em> = <em>l</em>}</span></p>
<p>So to generate <code>a*b*</code> of a fixed length <span
class="math inline"><em>l</em></span>, one option is to traverse all the
2-convolutions and generate the string from it, something like</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>strings <span class="op">=</span> [ <span class="st">&quot;a&quot;</span><span class="op">*</span>i <span class="op">+</span> <span class="st">&quot;b&quot;</span><span class="op">*</span>j <span class="op">+</span> <span class="st">&quot;c&quot;</span><span class="op">*</span>k <span class="cf">for</span> i,j,k <span class="kw">in</span> convolutions2(l) ]</span></code></pre></div>
<p>A “traditional” implementation of <code>convolutions2</code> would
be:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convolutions2(l):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,l<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        results.append((i,l<span class="op">-</span>i))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span></code></pre></div>
<p>All well and good; but I have a qualm with this. I want the
convolutions in an order such that each adjacent convolution differs as
little as possible. This algorithm doesn’t exactly convince me that this
is the best order for that purpose. But this is skipping ahead; first,
“differs” needs defined.</p>
<p>Hamming distance is appropriate for this. Given two 2-convolutions,
the distance is: <span
class="math display"><em>H</em>(<em>a</em>,<em>b</em>) = |<em>a</em><sub>0</sub>−<em>b</em><sub>0</sub>| + |<em>a</em><sub>1</sub>−<em>b</em><sub>1</sub>|</span></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conv_dist(a, b):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="bu">map</span>(<span class="bu">abs</span>, <span class="bu">map</span>(<span class="kw">lambda</span> t: t[<span class="dv">0</span>]<span class="op">-</span>t[<span class="dv">1</span>], <span class="bu">zip</span>(a,b))))</span></code></pre></div>
<p>This would represent the number of edits necessary to make the two
strings equal.</p>
<p>The naive approach is to check all path permutations and select
whichever has the smallest distance sum. If <span
class="math inline"><em>V</em> = Conv<sub><em>l</em>, <em>k</em></sub></span>
this would require <span class="math inline">|<em>V</em>|!</span>
iterations which is not feasible for large <span
class="math inline">|<em>V</em>|</span>. A better idea: since we’re
dealing with adjacency and paths, what about a graph representation?</p>
<p>To represent the problem as a graph, each 2-convolution is
represented by a node. The graph is complete: every node has an edge to
every other node. The weight of an edge is the hamming distance between
the two nodes.</p>
<p>The objective then is to find the graph traversal that results in the
minimum edge weight sum. Intuitively, since the graph is complete, the
optimal move from one node <span class="math inline"><em>n</em></span>
to another is the edge with the smallest distance.</p>
<p>While the above explains how to select the next node, what about the
initial node? My initial choice is <span
class="math inline">(0,<em>l</em>)</span>. Why?</p>
<p>First, what would a minimum edit look like? For a 2-convolution, any
of <span class="math inline">{(+1,−1), (−1,+1)}</span>. These two
clearly preserve the sum, i.e. <span
class="math inline"><em>a</em> + <em>b</em> = (<em>a</em>+1) + (<em>b</em>−1) = (<em>a</em>−1) + (<em>b</em>+1) = <em>l</em></span>.
<span class="math inline">(0,0)</span> is the other solution that
preserves the sum but obviously performs no transition. N.B. there are
some exceptions w.r.t bounds.</p>
<p>With this in mind, starting at <span
class="math inline">(0,<em>l</em>)</span> would leave no choice but
<span class="math inline">(1,<em>l</em>−1)</span>. Since a node is only
visited once, the next minimum change leads to <span
class="math inline">(2,<em>l</em>−2)</span> and so on. Eventually this
leads to <span class="math inline">(<em>l</em>,0)</span> covering all
convolutions.</p>
<p>Putting everything together, here’s the graph traversal in
Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_conv2_path(n) <span class="op">-&gt;</span> List[Tuple[<span class="bu">int</span>]]:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    conv <span class="op">=</span> convolutions2(n)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    curr_node <span class="op">=</span> (<span class="dv">0</span>,n)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>([curr_node])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [curr_node]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        neighbor_nodes <span class="op">=</span> [ n <span class="cf">for</span> n <span class="kw">in</span> conv <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> visited ]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> neighbor_nodes <span class="op">==</span> []:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        curr_node <span class="op">=</span> <span class="bu">min</span>(neighbor_nodes, key<span class="op">=</span><span class="kw">lambda</span> n: conv_dist(curr_node,n))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        path.append(curr_node)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        visited.add(curr_node)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path</span></code></pre></div>
<p><img src="../img/conv2_path.svg"></p>
<p>It’s true that this method and the “traditional” method defined above
seem to have the same output. See:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> vt, vs <span class="kw">in</span> <span class="bu">zip</span>(conv.convolutions2(<span class="dv">10</span>), conv.minimum_conv2_path(<span class="dv">10</span>)):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>...     <span class="bu">print</span>(vt, vs)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>... </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">10</span>) (<span class="dv">0</span>, <span class="dv">10</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">9</span>) (<span class="dv">1</span>, <span class="dv">9</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>, <span class="dv">8</span>) (<span class="dv">2</span>, <span class="dv">8</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="dv">7</span>) (<span class="dv">3</span>, <span class="dv">7</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span>, <span class="dv">6</span>) (<span class="dv">4</span>, <span class="dv">6</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>(<span class="dv">5</span>, <span class="dv">5</span>) (<span class="dv">5</span>, <span class="dv">5</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">6</span>, <span class="dv">4</span>) (<span class="dv">6</span>, <span class="dv">4</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>(<span class="dv">7</span>, <span class="dv">3</span>) (<span class="dv">7</span>, <span class="dv">3</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>(<span class="dv">8</span>, <span class="dv">2</span>) (<span class="dv">8</span>, <span class="dv">2</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>(<span class="dv">9</span>, <span class="dv">1</span>) (<span class="dv">9</span>, <span class="dv">1</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>(<span class="dv">10</span>, <span class="dv">0</span>) (<span class="dv">10</span>, <span class="dv">0</span>)</span></code></pre></div>
<p>As for the edit distance, it’s always 2 as predicted:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> n, np <span class="kw">in</span> <span class="bu">zip</span>(c, c[<span class="dv">1</span>:]):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>...     <span class="bu">print</span>(<span class="ss">f&#39;</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">-&gt;</span><span class="sc">{</span>np<span class="sc">}</span><span class="ss"> dist: </span><span class="sc">{</span>conv<span class="sc">.</span>conv_dist(n,np)<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>... </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">10</span>)<span class="op">-&gt;</span>(<span class="dv">1</span>, <span class="dv">9</span>) dist: <span class="dv">2</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">9</span>)<span class="op">-&gt;</span>(<span class="dv">2</span>, <span class="dv">8</span>) dist: <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>, <span class="dv">8</span>)<span class="op">-&gt;</span>(<span class="dv">3</span>, <span class="dv">7</span>) dist: <span class="dv">2</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="dv">7</span>)<span class="op">-&gt;</span>(<span class="dv">4</span>, <span class="dv">6</span>) dist: <span class="dv">2</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span>, <span class="dv">6</span>)<span class="op">-&gt;</span>(<span class="dv">5</span>, <span class="dv">5</span>) dist: <span class="dv">2</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>(<span class="dv">5</span>, <span class="dv">5</span>)<span class="op">-&gt;</span>(<span class="dv">6</span>, <span class="dv">4</span>) dist: <span class="dv">2</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">6</span>, <span class="dv">4</span>)<span class="op">-&gt;</span>(<span class="dv">7</span>, <span class="dv">3</span>) dist: <span class="dv">2</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>(<span class="dv">7</span>, <span class="dv">3</span>)<span class="op">-&gt;</span>(<span class="dv">8</span>, <span class="dv">2</span>) dist: <span class="dv">2</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>(<span class="dv">8</span>, <span class="dv">2</span>)<span class="op">-&gt;</span>(<span class="dv">9</span>, <span class="dv">1</span>) dist: <span class="dv">2</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>(<span class="dv">9</span>, <span class="dv">1</span>)<span class="op">-&gt;</span>(<span class="dv">10</span>, <span class="dv">0</span>) dist: <span class="dv">2</span></span></code></pre></div>
<p>And finally, the generated strings:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> i,j <span class="kw">in</span> conv.minimum_conv2_path(<span class="dv">10</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>...     <span class="bu">print</span>(<span class="st">&quot;a&quot;</span><span class="op">*</span>i <span class="op">+</span> <span class="st">&quot;b&quot;</span><span class="op">*</span>j)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>... </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>bbbbbbbbbb</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>abbbbbbbbb</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>aabbbbbbbb</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>aaabbbbbbb</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>aaaabbbbbb</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>aaaaabbbbb</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>aaaaaabbbb</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>aaaaaaabbb</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>aaaaaaaabb</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>aaaaaaaaab</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>aaaaaaaaaa</span></code></pre></div>
<p>Concretely it seems to work for 2-convolutions… but will it work for
k-convolutions where <span class="math inline"><em>k</em> &gt; 2</span>?
Some questions:</p>
<ul>
<li>For any k-convolution, are all edges on the minimum path weight
2?</li>
<li>Is the traditional k-convolution generation always equivalent to the
minimum path?</li>
<li>The prior examples used <span
class="math inline"><em>l</em> = 10</span>. Does it work for all <span
class="math inline"><em>l</em> ≥ 0</span>?</li>
</ul>
<p><a href="https://github.com/capricorn/convolutions">Post code,
etc</a></p>
</body>
</html>
